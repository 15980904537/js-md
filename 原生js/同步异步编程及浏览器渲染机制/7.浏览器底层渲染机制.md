- 浏览器是可以开辟多个进程/线程的

  - GUI 渲染线程：渲染页面
  - JS 引擎线程：渲染 JS 代码的
  - HTTP 网络线程，可以开辟 N 多个：从服务器获取资源和数据的
  - 定时器监听线程
  - DOM 监听线程

- 渲染页面过程中

  - 遇到 style 内嵌样式，GUI 直接渲染即可
    ->如果 CSS 代码量比较少，我么直接内嵌即可，拉去 HTML 的时候，同时 CSS 也回来了，渲染的时候直接就渲染了
    ->但是如果 CSS 代码比较多，如果还用内嵌，一方面会影响 HTML 的拉取速度，也不利于代码的维护，此时还是用外链的方式比较好
  - 遇到 link，浏览器开辟一个 HTTP 线程去请求资源文件信息，同时 GUI 继续向下渲染「异步」
    - 浏览器同时能够发送的 HTTP 请求是有数量限制的（谷歌：5~7 个）
    - 超过最大并发限制的 HTTP 请求需要排队等待
      ->HTTP 请求一定是越少越好...
  - 遇到@import，浏览器也是开辟 HTTP 线程去请求资源，但是此时 GUI 也暂定了（导入式样式会阻碍 GUI 的渲染），当资源请求回来之后，GUI 才能继续渲染「同步」
    ->真实项目中应该避免使用@import

- 遇到 <script src='xxx/xxx.js'>，会阻碍 GUI 的渲染 + defer：和 link 是类似的机制了，不会阻碍 GUI 渲染，当 GUI 渲染完，才会把请求回来的 JS 去渲染... + async：请求 JS 资源是异步的「单独开辟 HTTP 去请求」，此时 GUI 继续渲染；但是一但当 JS 请求回来，会立即暂停 GUI 的处理，接下来去渲染 JS...
  ->加入我们有 5 个 JS 的请求，如果不设置任何属性，肯定是按照顺序请求和渲染 JS 的「依赖关系是有效的」；但是如果设置 async，谁先请求回来就先渲染谁，依赖关系是无效的；如果使用 defer 是可以建立依赖关系的(浏览器内部在 GUI 渲染完成后，等待所有设置 defer 的资源都请求回来，再按照编写的依赖顺序去加载渲染 js)；

- 真实项目开发，我们一般把 link 放在页面的头部「是为了在没有渲染 DOM 的时候，就通知 HTTP 去请求 CSS 了，这样 DOM 渲染玩，CSS 也差不多回来了，更有效的利用时间，提高页面的渲染速度」；我们一般把 JS 放在页面的底部，防止其阻碍 GUI 的渲染，如果不放在底部，我们最好设置上 async/defer...；

- DOM TREE（DOMContentLoaded 事件触发）
  -> 「执行 JS」? -> CSSOM TREE -> RENDER TREE 渲染树「浏览器未来是按照这个树来绘制页面的」-> Layout 布局计算「回流/重排」-> Painting 绘制「重绘」{ 分层绘制 }

  - 页面第一次渲染，必然会引发一次回流和重绘
  - 如果我们改变了元素的位置和大小，浏览器需要重新计算元素在视口中的位置和大小信息，重新计算的过程是回流/重排，一但发 生了回流操作，一定也会触发重绘「很消耗性能：DOM 操作消耗性能，90%说的都是它」
  - 但是如果只是一些普通样式的改变，位置和大小不变，只需要重绘即可
